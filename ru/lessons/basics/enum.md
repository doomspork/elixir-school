---
version: 0.9.0
layout: page
title: Enum
category: basics
order: 3
lang: ru
---

Набор алгоритмов для операций с коллекциями.

{% include toc.html %}

## Enum

Модуль `Enum` включает в себя более ста функций для работы с коллекциями, которые описаны в предыдущем уроке.

Этот урок содержит только небольшую часть функций. Для того, чтобы увидеть полный список функций - посетите официальную документацию по [`Enum`](http://elixir-lang.org/docs/stable/elixir/Enum.html) . Для документации по "ленивым" операциям есть отдельная документация в модуле [`Stream`](http://elixir-lang.org/docs/stable/elixir/Stream.html).

### all?

При использовании `all?`, как и большей части `Enum` в целом, мы передаем функцию, которая будет применяться к элементам коллекции. В случае с `all?` если хоть один элемент коллекции не вернет `true` в качестве результата, то результатом будет `false`:

```elixir
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end)
false
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) > 1 end)
true
```

### any?

И наоборот, `any?` вернет `true` если хотя бы один элемент в коллекции выполнится в `true`:

```elixir
iex> Enum.any?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 5 end)
true
```

### chunk

Если нужно разбить коллекцию на меньшие группы, метод `chunk` - это то, что нужно:

```elixir
iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]
```

Также есть несколько дополнительных опций, которые вы можете посмотреть в документации: [`chunk/2`](http://elixir-lang.org/docs/stable/elixir/Enum.html#chunk/2).

### chunk_by

Если нужно разделить коллекцию по какому-то другому признаку кроме количества, есть метод `chunk_by/2`. Он принимает коллекцию и функцию. Когда возвращаемое функцией значение изменяется, начинается формирование новой группы:

```elixir
iex> Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"]]
iex> Enum.chunk_by(["one", "two", "three", "four", "five", "six"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"], ["six"]]
```

### map_every

Порой недостаточно просто разбить коллекцию на части. Если коллекция упорядочена должным образом, можно воспользоваться функцией map_every/3, позволяющей пройтись только по интересующим нас элементам:

```elixir
iex> Enum.map_every([1, 2, 3, 4], 2, fn x -> x * 2 end)
[2, 2, 6, 4]
``` 

### each

Когда нужно пройти по коллекции без создания нового значения - используется метод `each`:

```elixir
iex> Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
one
two
three
```

__Замечание__: Метод `each` не возвращает атом `:ok`.

### map

Когда нужно применить функцию для преобразования каждого элемента коллекции - подходит функция `map`:

```elixir
iex> Enum.map([0, 1, 2, 3], fn(x) -> x - 1 end)
[-1, 0, 1, 2]
```

### min

Функция `min` возвращает минимальное значение коллекции:

```elixir
iex> Enum.min([5, 3, 0, -1])
-1
```


`min/2` делает то же самое, но позволяет указать значение по умолчанию в анонимной функции:

```elixir
iex> Enum.min([], fn -> :foo end)
:foo
```

### max

Функция `max` находит максимальное значение в коллекции:

```elixir
iex> Enum.max([5, 3, 0, -1])
5
```

`max/2` делает то же самое, но как и в примере с `min/2`, позволяет передать значение по умолчанию:

```elixir
Enum.max([], fn -> :bar end)
:bar
```

### reduce

С помощью функции `reduce` можно объединить все элементы коллекции в единое значение. Для этого можно передать опциональное значение-аккумулятор. Если аккумулятор не передан, используется первое значение:

```elixir
iex> Enum.reduce([1, 2, 3], 10, fn(x, acc) -> x + acc end)
16
iex> Enum.reduce([1, 2, 3], fn(x, acc) -> x + acc end)
6
iex> Enum.reduce(["a","b","c"], "1", fn(x,acc)-> x <> acc end)
"cba1"
```

### sort

Сортировка коллекций реализуется не одной, а двумя функциями `sort`. Первая использует встроенный в язык механизм сравнения:

```elixir
iex> Enum.sort([5, 6, 1, 3, -1, 4])
[-1, 1, 3, 4, 5, 6]

iex> Enum.sort([:foo, "bar", Enum, -1, 4])
[-1, 4, Enum, :foo, "bar"]
```

Вторая позволяет передать собственную функцию для сравнения элементов:

```elixir
# с нашей функцией
iex> Enum.sort([%{:val => 4}, %{:val => 1}], fn(x, y) -> x[:val] > y[:val] end)
[%{val: 4}, %{val: 1}]

# без неё
iex> Enum.sort([%{:count => 4}, %{:count => 1}])
[%{count: 1}, %{count: 4}]
```

### uniq_by

Мы можем использовать `uniq_by/2` для удаления дубликатов из коллекций:
 
```elixir
iex> Enum.uniq_by([1, 2, 3, 2, 1, 1, 1, 1, 1], fn x -> x end)
[1, 2, 3]
```

Ранее эта функция называлась `uniq/1`. Старый вариант помечен устаревшим в Elixir 1.4 и будет выдавать предупреждение при использовании.
