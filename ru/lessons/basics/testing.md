---
layout: page
title: Тестирование
category: basics
order: 12
lang: ru
---

Тестирование &mdash; важная часть разработки.  В этом уроке мы узнаем, как тестировать наш Elixir код с помощью ExUnit, и познакомимся с некоторыми отличными приёмами.

{% include toc.html %}

## ExUnit

В Elixir есть встроенный фреймворк для тестирования &mdash; ExUnit и он содержит всё необходимое для тщательного тестирования нашего кода.  Перед тем как двигаться дальше, важно отметить, что тесты реализованы в виде скриптов Elixir, поэтому нам надо использовать расширение  `.exs`.  Для того, чтобы мы могли выполнять наши тесты, нужно запустить ExUnit с помощью `ExUnit.start()`, обычно это делается в `test/test_helper.exs`.

Когда мы сгенерировали проект-пример из прошлого урока, mix сделал для нас тест, который можно найти в `test/example_test.exs`:

```elixir
defmodule ExampleTest do
  use ExUnit.Case
  doctest Example

  test "the truth" do
    assert 1 + 1 == 2
  end
end
```

Тесты проекта можно запустить с помощью `mix test`.  Если мы сделаем это, то увидим примерно следующее:

```shell
Finished in 0.03 seconds (0.02s on load, 0.01s on tests)
1 tests, 0 failures
```

### assert

Если вы когда-либо ранее писали тесты, вы должны быть знакомы с `assert`; в некоторых фреймворках роль `assert` выполняют `should` или `expect`.

Макрос `assert` используется, чтобы проверить, что выражение истинно.  В случае, если это не так, возникнет ошибка, а тесты завершатся с ошибкой.  Давайте изменим наш пример и запустим `mix test`, чтобы протестировать ошибку:

```elixir
defmodule ExampleTest do
  use ExUnit.Case
  doctest Example

  test "the truth" do
    assert 1 + 1 == 3
  end
end
```

Сейчас мы увидим другой результат:

```shell
  1) test the truth (ExampleTest)
     test/example_test.exs:5
     Assertion with == failed
     code: 1 + 1 == 3
     lhs:  2
     rhs:  3
     stacktrace:
       test/example_test.exs:6

......

Finished in 0.03 seconds (0.02s on load, 0.01s on tests)
1 tests, 1 failures
```

ExUnit покажет, какое именно утверждение было ошибочным, какое значение ожидалось и какое было получено на самом деле.

### refute

`refute` относится к `assert` также, как `unless` к `if`.  Используйте `refute`, если вы хотите убедиться, что выражение всегда ложно.

### assert_raise

Иногда может понадобиться заявить, что возникла ошибка, и мы можем сделать это с помощью `assert_raise`.  Мы столкнёмся с примером применения `assert_raise` в следующем уроке о Plug.

## Настройка теста

В некоторых случаях перед тестами необходимо произвести настройку.  Сделать это можно с помощью макросов `setup` и `setup_all`.  `setup` вызывается перед каждым тестом, а `setup_all` &mdash; однажды перед всем набором.  Ожидается, что они вернут кортеж вида `{:ok, state}`, `state` будет доступен для наших тестов.

В качестве примера изменим наш код и воспользуемся `setup_all`:

```elixir
defmodule ExampleTest do
  use ExUnit.Case
  doctest Example

  setup_all do
    {:ok, number: 2}
  end

  test "the truth", state do
    assert 1 + 1 == state[:number]
  end
end
```

## Использование "заглушек"

Простой совет касательно использования заглушек в Elixir: не делайте этого.  Возможно, Вам по привычке захочется воспользоваться "заглушкой", но это крайне не приветствуется сообществом Elixir по веским причинам.  Если Вы будете следовать принципам правильного проектирования, конечный код будет легко тестировать в качестве индивидуальных компонентов.

Не поддавайтесь искушению.
