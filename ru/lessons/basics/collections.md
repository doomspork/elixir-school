---
layout: page
title: Коллекции
category: basics
order: 2
lang: ru
---

Списки, кортежи, ключевые списки, ассоциативные массивы и функциональные комбинаторы.

{% include toc.html %}

## Списки
Списки - это обычные коллекции значений. Они могут включать различные типы и неуникальные значения.

```elixir
iex> [3.41, :pie, "Apple"]
[3.41, :pie, "Apple"]
```

В Elixir списки являются связанными списками (linked list). Это означает, что получение длины списка имеет сложность `O(n)`. По этой причине добавлять элементы в начало списка намного быстрее, чем в конец.

```elixir
iex> list = [3.41, :pie, "Apple"]
[3.41, :pie, "Apple"]
iex> ["π"] ++ list
["π", 3.41, :pie, "Apple"]
iex> list ++ ["Cherry"]
[3.41, :pie, "Apple", "Cherry"]
```

### Объединение списков

Для объединения списков используется оператор `++/2`:

```elixir
iex> [1, 2] ++ [3, 4, 1]
[1, 2, 3, 4, 1]
```

### Вычитание списков

Оператор `--/2` предоставляет возможность вычитать списки. Не будет ошибкой вычитание отсутствующего элемента:

```elixir
iex> ["foo", :bar, 42] -- [42, "bar"]
["foo", :bar]
```

+**Замечание:** Для сопоставления элементов используется [строгое сравнение](../basics.md#section-12).

### Голова / Хвост

При использовании списков очень частой операцией является получение "головы" и "хвоста" списка. "Головой" является первый элемент, а "хвостом" - остальные элементы. Elixir предоставляет два оператора `hd` и `tl` для работы с этими частями:

```elixir
iex> hd [3.41, :pie, "Apple"]
3.41
iex> tl [3.41, :pie, "Apple"]
[:pie, "Apple"]
```

Кроме этого, того же результата можно добиться с использованием оператора `|`. Мы его часто встретим в последующих уроках.

```elixir
iex> [h|t] = [3.41, :pie, "Apple"]
[3.41, :pie, "Apple"]
iex> h
3.41
iex> t
[:pie, "Apple"]
```

## Кортежи

Кортежи похожи на списки, но хранятся в памяти последовательно. Это дает возможность быстро получить определенный элемент и длину кортежа. Но изменения становятся "дорогими", так как для этого создаваемый кортеж должен быть целиком скопирован в новую область памяти. Кортежи определяются с помощью фигурных скобок:

```elixir
iex> {3.41, :pie, "Apple"}
{3.41, :pie, "Apple"}
```

Часто они используются как механизм для получения дополнительной информации из функций. Полезность этого будет видна позже, когда мы будем углубляться в сопоставление с образцом (pattern matching):

```elixir
iex> File.read("path/to/existing/file")
{:ok, "... contents ..."}
iex> File.read("path/to/unknown/file")
{:error, :enoent}
```

## Ключевые списки

Ключевые списки и ассоциативные массивы являются имплементациями ассоциативных коллекций в Elixir. В Elixir ключевой список - это специальный список из кортежей, первым элементом которых является атом. По скорости они идентичны спискам.

```elixir
iex> [foo: "bar", hello: "world"]
[foo: "bar", hello: "world"]
iex> [{:foo, "bar"}, {:hello, "world"}]
[foo: "bar", hello: "world"]
```

Три характеристики этой структуры данных показывают ее важность:

+ Ключи являются атомами.
+ Ключи имеют свой порядок.
+ Ключи неуникальны.

По этой причине она часто используется для передачи параметров в функции.

## Ассоциативные массивы

В Elixir ассоциативный массив - это хранилище типа ключ-значение с возможностью быстрого получения информации по ключу. В отличие от ключевых списков, они поддерживают любой тип ключей и не сохраняют порядок следования. Ассоциативный массив объявляется с помощью синтаксиса `%{}`:

```elixir
iex> map = %{:foo => "bar", "hello" => :world}
%{:foo => "bar", "hello" => :world}
iex> map[:foo]
"bar"
iex> map["hello"]
:world
```

С версии Elixir 1.2 переменные поддерживаются в качестве ключей:

```elixir
iex> key = "hello"
"hello"
iex> %{key => "world"}
%{"hello" => "world"}
```

Если в эту структуру данных добавляется новый ключ, он перепишет старое значение:

```elixir
iex> %{:foo => "bar", :foo => "hello world"}
%{foo: "hello world"}
```

Как видно из вывода команды выше, также есть специальный короткий синтаксис для ассоциативных массивов, ключами которых являются только атомы:

```elixir
iex> %{foo: "bar", hello: "world"}
%{foo: "bar", hello: "world"}

iex> %{foo: "bar", hello: "world"} == %{:foo => "bar", :hello => "world"}
true
```
