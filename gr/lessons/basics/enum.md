---
layout: page
title: Enum
category: basics
order: 3
lang: gr
---

Μια συλλογή αλγορίθμων για την απαρίθμηση συλλογών.

{% include toc.html %}

## Enum

Η ενότητα `Enum` περιλαμβάνει πάνω από εκατό συναρτήσεις για να δουλέψουμε με τις συλλογές που μάθαμε στο προηγούμενο μάθημα.

Αυτό το μάθημα θα καλύψει μόνο ένα μέρος των διαθέσιμων συναρτήσεων, για να δείτε τις συναρτήσεις στο σύνολό τους επισκεφθείτε τα επίσημα έγγραφα του [`Enum`](http://elixir-lang.org/docs/stable/elixir/Enum.html).  Για τεμπέλικη απαρίθμηση (lazy enumeration) χρησιμοποιήστε την ενότητα [`Stream`](http://elixir-lang.org/docs/stable/elixir/Stream.html).


### all?

Όταν χρησιμοποιούμε την `all?`, και το μεγαλύτερο μέρος της `Enum`, παρέχουμε μια συνάρτηση την οποία εφαρμόζουμε σε όλα τα στοιχεία της συλλογής.  Στην περίπτωση της `all?`, όλη η συλλογή πρέπει να επιστρέφει `true`, αλλιώς θα επιστρέψει `false`:

```elixir
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 3 end)
false
iex> Enum.all?(["foo", "bar", "hello"], fn(s) -> String.length(s) > 1 end)
true
```

### any?

Αντίθετα με την προηγούμενη, η `any?` θα επιστρέψει `true` αν τουλάχιστον ένα στοιχείο αξιολογηθεί σαν `true`:

```elixir
iex> Enum.any?(["foo", "bar", "hello"], fn(s) -> String.length(s) == 5 end)
true
```

### chunk

Αν χρειαστεί να σπάσουμε την συλλογή σε μικρότερα μέρη, η `chunk` είναι μάλλον η συνάρτηση που ψάχνουμε:

```elixir
iex> Enum.chunk([1, 2, 3, 4, 5, 6], 2)
[[1, 2], [3, 4], [5, 6]]
```

Yπάρχουν μερικές επιλογές για την `chunk` αλλά δεν θα τις αναλύσουμε, για να μάθετε περισσότερα επισκεφθείτε την [`chunk/2`](http://elixir-lang.org/docs/stable/elixir/Enum.html#chunk/2) στα επίσημα κείμενα.

### chunk_by

Αν χρειάστει να ομαδοποιήσουμε την συλλογή μας βασιζόμενοι σε κάτι πέραν του μεγέθους, μπορούμε να χρησιμοποιήσουμε την `chunk_by/2` συνάρτηση.  Δέχεται μια ομαδοποίηση και μια συνάρτηση, και όταν αλλάζει η επιστροφή της συνάρτησης ξεκινάει μια νέα ομάδα:

```elixir
iex> Enum.chunk_by(["one", "two", "three", "four", "five"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"]]
iex> Enum.chunk_by(["one", "two", "three", "four", "five", "six"], fn(x) -> String.length(x) end)
[["one", "two"], ["three"], ["four", "five"], ["six"]]
```

### each

Μπορεί να είναι απαραίτητο να περάσετε όλη τη συλλογή χωρίς να παραχθεί νέα τιμή. Σε αυτή την περίπτωση χρησιμοποιούμε την `each`:

```elixir
iex> Enum.each(["one", "two", "three"], fn(s) -> IO.puts(s) end)
one
two
three
```

__Σημείωση__: Η συνάρτηση `each` επιστρέφει το άτομο `:ok`.

### map

Για να εφαρμόσουμε την συνάρτησή μας σε κάθε αντικείμενο και να φτιάξουμε μια νέα συλλογή πρέπει να απευθυνθούμε στην συνάρτηση `map`:

```elixir
iex> Enum.map([0, 1, 2, 3], fn(x) -> x - 1 end)
[-1, 0, 1, 2]
```

### min

Για να βρούμε την μικρότερη (`min`) τιμή στην συλλογή:

```elixir
iex> Enum.min([5, 3, 0, -1])
-1
```

### max

Επιστρέφει την μεγαλύτερη (`max`) τιμή στην συλλογή:

```elixir
iex> Enum.max([5, 3, 0, -1])
5
```

### reduce

Με την `reduce` μπορούμε να μαζέψουμε την συλλογή μας σε μία τιμή.  Για να το κάνουμε αυτό, παρέχουμε έναν προεραιτικό συσσωρευτή (το `10` σε αυτό το παράδειγμα) ο οποίος περνάει στη συνάρτηση.  Αν δεν παρέχουμε συσσωρευτή, χρησιμοποιείται η πρώτη τιμή:

```elixir
iex> Enum.reduce([1, 2, 3], 10, fn(x, acc) -> x + acc end)
16
iex> Enum.reduce([1, 2, 3], fn(x, acc) -> x + acc end)
6
iex> Enum.reduce(["a","b","c"], "1", fn(x,acc)-> x <> acc end)
"cba1"
```

### sort

Η ταξινόμηση των συλλογών μας γίνεται εύκολη όχι με μία, αλλά με δύο συναρτήσεις `sort`.  Η πρώτη επιλογή που έχουμε στη διάθεσή μας χρησιμοποιεί την ταξινόμηση όρων για να καθορίσει την σειρά ταξινόμησης:

```elixir
iex> Enum.sort([5, 6, 1, 3, -1, 4])
[-1, 1, 3, 4, 5, 6]

iex> Enum.sort([:foo, "bar", Enum, -1, 4])
[-1, 4, Enum, :foo, "bar"]
```

Η άλλη επιλογή μας επιτρέπει να παρέχουμε μια συνάρτηση ταξινόμησης:

```elixir
# με τη συνάρτησή μας
iex> Enum.sort([%{:val => 4}, %{:val => 1}], fn(x, y) -> x[:val] > y[:val] end)
[%{val: 4}, %{val: 1}]

# χωρίς
iex> Enum.sort([%{:count => 4}, %{:count => 1}])
[%{count: 1}, %{count: 4}]
```

### uniq

Μπορούμε να χρησιμοποιήσουμε την `uniq` για να αφαιρέσουμε διπλότυπα από τις συλλογές μας:

```elixir
iex> Enum.uniq([1, 2, 2, 3, 3, 3, 4, 4, 4, 4])
[1, 2, 3, 4]
```
