---
version: 1.0.2
title: Meta programlama
---

Meta programlama, kod yazmak için kod kullanma işlemidir.
Elixiri ihtiyaçlarımız doğrultusunda  genişletmeye ve kodun dinamik olarak değiştirilmesini sağlıyor.
Elixir'in kaputun altında nasıl temsil edildiğine, sonra nasıl değiştireceğimize bakarak başlayacağız ve sonunda bu bilgiyi onu genişletmek için kullanabiliriz.

Uyarı: Meta programlama zor ve sadece gerektiğinde kullanılmalıdır.
Aşırı kullanım neredeyse anlaşılması ve hata ayıklaması zor olan karmaşık kodlara yol açacaktır.




{% include toc.html %}

## Quote

Meta programlamanın ilk adımı, ifadelerin nasıl temsil edildiğini anlamaktır.
Elixir'de yazdığımız kodun arka planda temsili olan soyut sözdizimi ağacı (AST), tupllerden oluşur.
Bu tupller üç bölüm içerir: fonksiyon adı, meta veriler ve fonksiyon argümanları.

Elixir bize `quote/2` fonksiyonu ile  kodumuzun arka planda temsil edildiği şekle dönüştüre biliriz:

```elixir
iex> quote do: 42
42
iex> quote do: "Hello"
"Hello"
iex> quote do: :world
:world
iex> quote do: 1 + 2
{:+, [context: Elixir, import: Kernel], [1, 2]}
iex> quote do: if value, do: "True", else: "False"
{:if, [context: Elixir, import: Kernel],
 [{:value, [], Elixir}, [do: "True", else: "False"]]}
```

Tuple olarak dönmeyen ilk üçe dikkate ettiniz mi? Dönüşüm 5 farklı şekilde yapılır :

```elixir
iex> :atom
:atom
iex> "string"
"string"
iex> 1 # Sayılar
1
iex> [1, 2] # Liste
[1, 2]
iex> {"hello", :world} # 2 elemanlı tuples
{"hello", :world}
```

## Unquote

Artık kodumuzun içsel yapısına nasıl ulaşabileceğimizi biliyoruz. Şimdi onu nasıl değiştirebileceğimize bakalım ? Yeni kod veya değerler enjekte etmek için `unquote/1` fonksiyonunu kullanırız.
`unquote / 1` anlamak için için bazı örneklere bakalım:

```elixir
iex> denominator = 2
2
iex> quote do: divide(42, denominator)
{:divide, [], [42, {:denominator, [], Elixir}]}
iex> quote do: divide(42, unquote(denominator))
{:divide, [], [42, 2]}
```

İlk örnekte, değişkenimiz `denominator`, AST değişkene erişmek için bir tuple içerir.
`unquote/1` örneğinde de tuple yeeine `denominator` ait değeri içerir.

## Macros

`quote/2` ve `unquote/1`  anladığımıza  göre  makroya başlamaya hazırız. Unutmamalıyız ki , makrolarıda, meta programlama gibi, idareli bir şekilde kullanılmalıdır..

En basit tanımla, makrolar, uygulamamıza değiştirilmiş fonksiyonları döndürmek için tasarlanmış özel fonksiyonlardır. Makronun bir fonksiyon olarak çağırmadan alıntılanmış bir fonksiyon ile  değiştirildiğini düşünün. Artık, Elixir'i makrolarla genişletmek ve uygulamalarımıza dinamik olarak kod eklemek için ihtiyacımız olan her şeye sahibiz.

We begin by defining a macro using `defmacro/2` which, like much of Elixir, is itself a macro (let that sink in).  As an example we'll implement `unless` as a macro.  Remember that our macro needs to return a quoted expression:

```elixir
defmodule OurMacro do
  defmacro unless(expr, do: block) do
    quote do
      if !unquote(expr), do: unquote(block)
    end
  end
end
```

Let's require our module and give our macro a whirl:

```elixir
iex> require OurMacro
nil
iex> OurMacro.unless true, do: "Hi"
nil
iex> OurMacro.unless false, do: "Hi"
"Hi"
```

Because macros replace code in our application, we can control when and what is compiled.  An example of this can be found in the `Logger` module.  When logging is disabled no code is injected and the resulting application contains no references or function calls to logging.  This is different from other languages where there is still the overhead of a function call even when the implementation is NOP.

To demonstrate this we'll make a simple logger that can either be enabled or disabled:

```elixir
defmodule Logger do
  defmacro log(msg) do
    if Application.get_env(:logger, :enabled) do
      quote do
        IO.puts("Logged message: #{unquote(msg)}")
      end
    end
  end
end

defmodule Example do
  require Logger

  def test do
    Logger.log("This is a log message")
  end
end
```

With logging enabled our `test` function would result in code looking something like this:

```elixir
def test do
  IO.puts("Logged message: #{"This is a log message"}")
end
```

If we disable logging the resulting code would be:

```elixir
def test do
end
```

## Debugging

Okay, right now we know how to use `quote/2`, `unquote/1` and write macros. But what if you have a huge chunk of quoted code and want to understand it? In this case, you can use `Macro.to_string/2`. Take a look at this example:

```elixir
iex> Macro.to_string(quote(do: foo.bar(1, 2, 3)))
"foo.bar(1, 2, 3)"
```

And when you want to look at the code generated by macros you can combine them with `Macro.expand/2` and `Macro.expand_once/2`, these functions expand macros into their given quoted code. The first may expand it several times, while the latter - only once. For example, let's modify `unless` example from the previous section:

```elixir
defmodule OurMacro do
  defmacro unless(expr, do: block) do
    quote do
      if !unquote(expr), do: unquote(block)
    end
  end
end

require OurMacro

quoted =
  quote do
    OurMacro.unless(true, do: "Hi")
  end
```

```elixir
iex> quoted |> Macro.expand_once(__ENV__) |> Macro.to_string |> IO.puts
if(!true) do
  "Hi"
end
```

If we run the same code with `Macro.expand/2`, it's intriguing:

```elixir
iex> quoted |> Macro.expand(__ENV__) |> Macro.to_string |> IO.puts
case(!true) do
  x when x in [false, nil] ->
    nil
  _ ->
    "Hi"
end
```

You may recall that we've mentioned `if` is a macro in Elixir, here we see it expanded into the underlying `case` statement.

### Private Macros

Though not as common, Elixir does support private macros.  A private macro is defined with `defmacrop` and can only be called from the module in which it was defined.  Private macros must be defined before the code that invokes them.

### Macro Hygiene

How macros interact with the caller's context when expanded is known as macro hygiene. By default macros in Elixir are hygienic and will not conflict with our context:

```elixir
defmodule Example do
  defmacro hygienic do
    quote do: val = -1
  end
end

iex> require Example
nil
iex> val = 42
42
iex> Example.hygienic
-1
iex> val
42
```

What if we wanted to manipulate the value of `val`?  To mark a variable as being unhygienic we can use `var!/2`.  Let's update our example to include another macro utilizing `var!/2`:

```elixir
defmodule Example do
  defmacro hygienic do
    quote do: val = -1
  end

  defmacro unhygienic do
    quote do: var!(val) = -1
  end
end
```

Let's compare how they interact with our context:

```elixir
iex> require Example
nil
iex> val = 42
42
iex> Example.hygienic
-1
iex> val
42
iex> Example.unhygienic
-1
iex> val
-1
```

By including `var!/2` in our macro we manipulated the value of `val` without passing it into our macro.  The use of non-hygienic macros should be kept to a minimum.  By including `var!/2` we increase the risk of a variable resolution conflict.

### Binding

We already covered the usefulness of `unquote/1`, but there's another way to inject values into our code: binding.  With variable binding we are able to include multiple variables in our macro and ensure they're only unquoted once, avoiding accidental revaluations. To use bound variables we need to pass a keyword list to the `bind_quoted` option in `quote/2`.

To see the benefit of `bind_quote` and to demonstrate the revaluation issue let's use an example.  We can start by creating a macro that simply outputs the expression twice:

```elixir
defmodule Example do
  defmacro double_puts(expr) do
    quote do
      IO.puts(unquote(expr))
      IO.puts(unquote(expr))
    end
  end
end
```

We'll try out our new macro by passing it the current system time.  We should expect to see it output twice:

```elixir
iex> Example.double_puts(:os.system_time)
1450475941851668000
1450475941851733000
```

The times are different!  What happened?  Using `unquote/1` on the same expression multiple times results in revaluation and that can have unintended consequences.  Let's update the example to use `bind_quoted` and see what we get:

```elixir
defmodule Example do
  defmacro double_puts(expr) do
    quote bind_quoted: [expr: expr] do
      IO.puts(expr)
      IO.puts(expr)
    end
  end
end

iex> require Example
nil
iex> Example.double_puts(:os.system_time)
1450476083466500000
1450476083466500000
```

With `bind_quoted` we get our expected outcome: the same time printed twice.

Now that we've covered `quote/2`, `unquote/1`, and `defmacro/2` we have all the tools necessary to extend Elixir to suit our needs.
